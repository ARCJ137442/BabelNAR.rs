//! æœ‰å…³ã€ŒNAVMæµ‹è¯•å·¥å…·ã€çš„æ•°æ®ç»“æ„æ”¯æŒ
//! * ğŸ¯æ„é€ åœ¨ã€ŒNAVMæŒ‡ä»¤ã€ä¹‹ä¸Šçš„è¶…é›†ï¼Œæ”¯æŒä¸æµ‹è¯•æœ‰å…³çš„æ•°æ®ç»“æ„å­˜å‚¨
//! * âœ¨[`NALInput`]ï¼šåœ¨ã€Œç›´æ¥å¯¹åº”CINè¾“å…¥è¾“å‡ºã€çš„ã€ŒNAVMæŒ‡ä»¤ã€ä¹‹ä¸Šï¼Œå¼•å…¥ã€Œç­‰å¾…ã€ã€Œé¢„æœŸã€ç­‰æœºåˆ¶
//! * âœ¨[`OutputExpectation`]ï¼šé¢å‘NALæµ‹è¯•ï¼Œå…·ä½“å®ç°ã€Œé¢„æœŸã€æœºåˆ¶

use narsese::{conversion::string::impl_lexical::format_instances::FORMAT_ASCII, lexical::Narsese};
use navm::{cmd::Cmd, output::Operation};
use std::{fmt::Display, time::Duration};
use thiserror::Error;

/// NAVMæµ‹è¯•ä¸­çš„ã€ŒNALè¾“å…¥ã€
/// * ğŸ“Œ`.nal`æ–‡ä»¶ä¸­ä¸€è¡Œçš„è¶…é›†
/// * ğŸ¯åœ¨åŸæœ‰NAVMæŒ‡ä»¤ä¸‹ï¼Œæ‰©å±•ä¸æµ‹è¯•æœ‰å…³çš„åŠŸèƒ½
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NALInput {
    /// ç½®å…¥
    /// * ğŸ¯å‘CINç½®å…¥NAVMæŒ‡ä»¤
    Put(Cmd),

    /// ç¡çœ 
    /// * ğŸ“„è¯­æ³•ç¤ºä¾‹ï¼š`''sleep 1s`
    /// * ğŸ“Œè°ƒç”¨[`thread::sleep`]å•çº¯ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼ˆå•ä½ï¼š[`Duration`]ï¼‰
    ///   * ğŸš©è¯­æ³•ä¸­å¸¸ç”¨çš„æ˜¯ç§’æ•°ï¼Œä½†è¿™é‡Œä¸ç›´æ¥å­˜å‚¨
    Sleep(Duration),

    /// è¾“å‡ºç­‰å¾…
    /// * ğŸ“„è¯­æ³•ç¤ºä¾‹ï¼š`''await: IN <A --> B>.`
    /// * ğŸ“Œåœ¨CINè¾“å‡ºä¸æŒ‡å®š[`Output`]ç¬¦åˆåï¼Œå†ç»§ç»­è¿è¡Œ
    /// * ğŸ¯ç”¨äºç»“åˆ`IN`ç­‰å¾…CINã€Œå›æ˜¾ã€
    Await(OutputExpectation),

    /// å¯¹ã€Œè¾“å‡ºå«æœ‰ã€çš„é¢„æœŸ
    /// * ğŸ“„è¯­æ³•ç¤ºä¾‹ï¼š`''expect-contains: ANSWER <A --> C>.`
    /// * ğŸ¯ç”¨äºã€Œåœ¨ç°æœ‰çš„è¾“å‡ºä¸­æ£€æŸ¥æ˜¯å¦ä»»ä¸€å’ŒæŒ‡å®šçš„[`Output`]ç¬¦åˆã€
    /// * ğŸ“„å¯¹åº”OpenNARSä¸­å¸¸æœ‰çš„`''outputMustContain('')`
    ExpectContains(OutputExpectation),

    /// ä¿å­˜ã€Œè¾“å‡ºç¼“å­˜ã€åˆ°æŒ‡å®šæ–‡ä»¶
    /// * ğŸ“„è¯­æ³•ç¤ºä¾‹ï¼š`''save-outputs: outputs.log`
    /// * ğŸ¯ç”¨äºã€Œå°†ç°æœ‰æ‰€æœ‰è¾“å‡ºä»¥ã€NAVMè¾“å‡ºçš„JSONæ ¼å¼ã€å­˜æ¡£è‡³æŒ‡å®šæ–‡ä»¶ä¸­ã€
    SaveOutputs(String),

    /// ç»ˆæ­¢è™šæ‹Ÿæœº
    /// * ğŸ¯ç”¨äºã€Œé¢„åŠ è½½NALã€æµ‹è¯•ã€ç»“æŸåï¼Œç¨‹åºè‡ªåŠ¨é€€å‡º/äº¤ç»™ç”¨æˆ·è¾“å…¥ã€
    /// * ğŸ“„è¯­æ³•ç¤ºä¾‹ï¼š
    ///   * `''terminate`
    ///   * `''terminate(if-no-user): å¼‚å¸¸çš„é€€å‡ºæ¶ˆæ¯ï¼`
    /// * ğŸ”§å¯é€‰çš„ã€Œå­å‚æ•°ã€
    ///   * `if-no-user`ï¼šä»…åœ¨ã€Œç”¨æˆ·æ— æ³•è¾“å…¥ã€æ—¶é€€å‡º
    Terminate {
        /// ä»…åœ¨ã€Œç”¨æˆ·æ— æ³•è¾“å…¥ã€æ—¶é€€å‡º
        /// * ğŸ¯ç”¨äºã€Œæµ‹è¯•å®Œæ¯•åäº¤ç»™ç”¨æˆ·è¾“å…¥ã€çš„æµ‹è¯•
        if_not_user: bool,

        /// é€€å‡ºçš„è¿”å›å€¼
        /// * ğŸ¯ç”¨äºã€Œæµ‹è¯•å®Œæ¯•åå‘å¤–éƒ¨ä¼ é€’ç»“æœã€çš„æµ‹è¯•
        /// * ğŸ’­å§‹ç»ˆæ³¨æ„è¿™åªæ˜¯ä¸ªçº¿æ€§æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œä¸è¦åšå¾—å¤ªå¤æ‚
        /// * ğŸš©ã€2024-04-02 23:56:34ã€‘ç›®å‰ä¸åœ¨æ­¤è£…è½½[`anyhow::Error`]ç±»å‹ï¼šé¿å…å¤æ‚
        result: std::result::Result<(), String>,
    },
}

/// è¾“å‡ºé¢„æœŸ
/// * ğŸ“Œå¯¹åº”è¯­æ³•ä¸­çš„`output_expectation`ç»“æ„
/// * ğŸ¯ç”¨äºç»Ÿä¸€è¡¨ç¤ºå¯¹ã€ŒNAVMè¾“å‡ºã€çš„é¢„æœŸ
///   * ğŸš©é™¤äº†ã€ŒåŸå§‹å†…å®¹ã€å¤–ï¼Œä¸[`Output`]ç±»å‹ä¸€è‡´
///   * âœ¨å¯è¿›è¡Œæœ‰å…³ã€Œæ£€æŸ¥èŒƒå›´ã€ã€Œä¸¥æ ¼æ€§ã€ç­‰æ›´ç»†è‡´çš„é…ç½®ï¼Œè€Œéä»…ä»…æ˜¯ã€Œæ–‡æœ¬åŒ…å«ã€
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct OutputExpectation {
    /// é¢„æœŸçš„ã€Œè¾“å‡ºç±»å‹ã€
    /// * ğŸš©å¯èƒ½æ²¡æœ‰ï¼šæ­¤æ—¶æ˜¯ã€Œé€šé…ã€æƒ…å½¢
    ///   * å¯¹ä»»ä½•å¯èƒ½çš„è¾“å…¥éƒ½é€‚ç”¨
    pub output_type: Option<String>,

    /// é¢„æœŸçš„ã€ŒNarseseã€å­—æ®µ
    /// * ğŸš©å¯èƒ½æ²¡æœ‰ï¼šæ­¤æ—¶æ˜¯ã€Œé€šé…ã€æƒ…å½¢
    ///   * å¯¹ä»»ä½•å¯èƒ½çš„è¾“å…¥éƒ½é€‚ç”¨
    /// * ğŸš©å¯¹å†…éƒ¨[`Narsese`]ä¼šè¿›è¡Œ**é€’å½’åŒ¹é…**
    pub narsese: Option<Narsese>,

    /// é¢„æœŸçš„ã€ŒNAVMæ“ä½œã€å­—æ®µ
    /// * ğŸš©å¯èƒ½æ²¡æœ‰ï¼šæ­¤æ—¶æ˜¯ã€Œé€šé…ã€æƒ…å½¢
    ///   * å¯¹ä»»ä½•å¯èƒ½çš„è¾“å…¥éƒ½é€‚ç”¨
    pub operation: Option<Operation>,
}

impl Display for OutputExpectation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OutputExpectation {{ {} {} {} }}",
            self.output_type.as_deref().unwrap_or("*"),
            match &self.narsese {
                Some(narsese) => FORMAT_ASCII.format_narsese(narsese),
                None => "*".to_string(),
            },
            self.operation
                .as_ref()
                .map(|op| op.to_string())
                .unwrap_or("*".to_string()),
        )
    }
}

/// é¢„æœŸé”™è¯¯
/// * ğŸ¯ç”¨äºå®šä¹‰å¯è¢«è¯†åˆ«çš„ã€ŒNALé¢„æœŸå¤±è´¥/è„±ç¦»é¢„æœŸã€é”™è¯¯
/// * ğŸš©ä½¿ç”¨[`thiserror`]å¿«æ·å®šä¹‰
#[derive(Error, Debug, Clone, PartialEq, Eq)]
pub enum OutputExpectationError {
    /// è¾“å‡ºæœªåŒ…å«é¢„æœŸ
    /// * ğŸ¯å¯¹åº”[`NALInput::ExpectContains`]
    /// * ğŸ“æ­¤å¤„`{0:?}`å‚ç…§<https://lib.rs/crates/thiserror>
    #[error("è¾“å‡ºå†…å®¹ä¸­ä¸å­˜åœ¨ç¬¦åˆé¢„æœŸçš„è¾“å‡ºï¼š{0}")]
    ExpectedNotExists(OutputExpectation),
}
